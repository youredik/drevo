name: Deploy Drevo

on:
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: "20"
  FUNCTION_NAME: drevo-api
  SPA_BUCKET: drevo-spa
  MEDIA_BUCKET: drevo-media

jobs:
  build-and-deploy:
    name: Build & Deploy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: |
            web-app/functions/package-lock.json
            web-app/frontend/package-lock.json

      # ─── Build backend ───────────────────────────────────
      - name: Install backend deps
        working-directory: web-app/functions
        run: npm ci

      - name: Typecheck backend
        working-directory: web-app/functions
        run: npx tsc --noEmit

      - name: Build backend
        working-directory: web-app/functions
        run: npm run build

      # ─── Build frontend ──────────────────────────────────
      - name: Install frontend deps
        working-directory: web-app/frontend
        run: npm ci

      - name: Build frontend
        working-directory: web-app/frontend
        run: npx next build
        env:
          NEXT_PUBLIC_API_URL: ""

      # ─── Install YC CLI ──────────────────────────────────
      - name: Cache YC CLI
        id: yc-cache
        uses: actions/cache@v4
        with:
          path: ~/yandex-cloud
          key: yc-cli-${{ runner.os }}

      - name: Install Yandex Cloud CLI
        if: steps.yc-cache.outputs.cache-hit != 'true'
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash

      - name: Add YC CLI to PATH
        run: echo "$HOME/yandex-cloud/bin" >> $GITHUB_PATH

      - name: Configure YC CLI
        run: |
          echo '${{ secrets.YC_SA_KEY }}' > /tmp/sa-key.json
          yc config set service-account-key /tmp/sa-key.json
          yc config set folder-id ${{ secrets.YC_FOLDER_ID }}

      # ─── Deploy Cloud Function ───────────────────────────
      - name: Get YDB info & Service Account ID
        id: yc-info
        run: |
          YDB_INFO=$(yc ydb database get drevo-db --format json)
          FULL_ENDPOINT=$(echo $YDB_INFO | jq -r '.endpoint')
          echo "ydb_endpoint=$(echo "$FULL_ENDPOINT" | cut -d'?' -f1 | sed 's|/$||')" >> $GITHUB_OUTPUT
          echo "ydb_database=$(echo "$FULL_ENDPOINT" | sed 's/.*database=\(.*\)/\1/')" >> $GITHUB_OUTPUT
          echo "sa_id=$(yc iam service-account get drevo-sa --format json | jq -r '.id')" >> $GITHUB_OUTPUT

      - name: Upload function package to S3
        run: |
          yc storage s3api put-object \
            --bucket=${{ env.MEDIA_BUCKET }} \
            --key=deploy/api.zip \
            --body=web-app/functions/dist/api.zip

      - name: Deploy Cloud Function
        run: |
          yc serverless function version create \
            --function-name=${{ env.FUNCTION_NAME }} \
            --runtime=nodejs22 \
            --entrypoint=handler.handler \
            --memory=256m \
            --execution-timeout=60s \
            --package-bucket-name=${{ env.MEDIA_BUCKET }} \
            --package-object-name=deploy/api.zip \
            --service-account-id=${{ steps.yc-info.outputs.sa_id }} \
            --environment="JWT_SECRET=${{ secrets.JWT_SECRET }},YDB_ENDPOINT=${{ steps.yc-info.outputs.ydb_endpoint }},YDB_DATABASE=${{ steps.yc-info.outputs.ydb_database }},MEDIA_MOUNT=/mnt/media" \
            --storage-mounts="mount-point=media,bucket=${{ env.MEDIA_BUCKET }},prefix=,read-only=false"

      # ─── Deploy SPA to Object Storage ────────────────────
      - name: Upload SPA
        run: |
          echo "=== Build output ==="
          find web-app/frontend/out -type f | wc -l

          echo "=== Uploading to ${{ env.SPA_BUCKET }} (parallel) ==="
          cd web-app/frontend/out

          upload_file() {
            local file="$1"
            local key="${file#./}"
            local ct
            case "${key##*.}" in
              html) ct="text/html; charset=utf-8" ;;
              css)  ct="text/css" ;;
              js)   ct="application/javascript" ;;
              json) ct="application/json" ;;
              svg)  ct="image/svg+xml" ;;
              png)  ct="image/png" ;;
              jpg|jpeg) ct="image/jpeg" ;;
              ico)  ct="image/x-icon" ;;
              txt)  ct="text/plain" ;;
              woff) ct="font/woff" ;;
              woff2) ct="font/woff2" ;;
              map)  ct="application/json" ;;
              *)    ct="application/octet-stream" ;;
            esac
            yc storage s3api put-object \
              --bucket=${{ env.SPA_BUCKET }} \
              --key="$key" \
              --body="$file" \
              --content-type="$ct" > /dev/null \
            && echo "  uploaded: $key ($ct)" \
            || echo "  FAILED: $key"
          }
          export -f upload_file

          find . -type f -print0 | xargs -0 -P 20 -n 1 bash -c 'upload_file "$1"' _
          wait
          FAILED=$(find . -type f -print0 | xargs -0 -P 20 -n 1 bash -c '
            f="$1"; key="${f#./}"
            case "${key##*.}" in
              html) ct="text/html; charset=utf-8" ;; css) ct="text/css" ;;
              js) ct="application/javascript" ;; json|map) ct="application/json" ;;
              svg) ct="image/svg+xml" ;; png) ct="image/png" ;;
              jpg|jpeg) ct="image/jpeg" ;; ico) ct="image/x-icon" ;;
              txt) ct="text/plain" ;; woff) ct="font/woff" ;; woff2) ct="font/woff2" ;;
              *) ct="application/octet-stream" ;;
            esac
            yc storage s3api head-object --bucket=$BUCKET --key="$key" > /dev/null 2>&1 || echo "$key"
          ' _ 2>/dev/null)
          if [ -n "$FAILED" ]; then
            echo "::error::Failed to upload: $FAILED"
            exit 1
          fi
          echo "=== Upload complete ==="

      # ─── Cleanup ─────────────────────────────────────────
      - name: Cleanup
        if: always()
        run: rm -f /tmp/sa-key.json
