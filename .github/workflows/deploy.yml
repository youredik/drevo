name: Deploy Drevo

on:
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: "20"
  FUNCTION_NAME: drevo-api
  SPA_BUCKET: drevo-spa
  MEDIA_BUCKET: drevo-media

jobs:
  # ─── Parallel build jobs ──────────────────────────────
  build-backend:
    name: Build Backend
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: web-app/functions/package-lock.json

      - name: Install deps
        working-directory: web-app/functions
        run: npm ci

      - name: Typecheck
        working-directory: web-app/functions
        run: npx tsc --noEmit

      - name: Build
        working-directory: web-app/functions
        run: npm run build

      - uses: actions/upload-artifact@v4
        with:
          name: backend-artifact
          path: web-app/functions/dist/api.zip
          retention-days: 1

  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: web-app/frontend/package-lock.json

      - name: Install deps
        working-directory: web-app/frontend
        run: npm ci

      - name: Build
        working-directory: web-app/frontend
        run: npx next build
        env:
          NEXT_PUBLIC_API_URL: ""

      - uses: actions/upload-artifact@v4
        with:
          name: frontend-artifact
          path: web-app/frontend/out/
          retention-days: 1

  # ─── Deploy (waits for both builds) ───────────────────
  deploy:
    name: Deploy
    needs: [build-backend, build-frontend]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: backend-artifact
          path: backend/

      - uses: actions/download-artifact@v4
        with:
          name: frontend-artifact
          path: frontend/

      # ─── Install YC CLI ──────────────────────────────────
      - name: Cache YC CLI
        id: yc-cache
        uses: actions/cache@v4
        with:
          path: ~/yandex-cloud
          key: yc-cli-${{ runner.os }}

      - name: Install Yandex Cloud CLI
        if: steps.yc-cache.outputs.cache-hit != 'true'
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash

      - name: Add YC CLI to PATH
        run: echo "$HOME/yandex-cloud/bin" >> $GITHUB_PATH

      - name: Configure YC CLI
        run: |
          echo '${{ secrets.YC_SA_KEY }}' > /tmp/sa-key.json
          yc config set service-account-key /tmp/sa-key.json
          yc config set folder-id ${{ secrets.YC_FOLDER_ID }}

      # ─── Deploy Cloud Function ───────────────────────────
      - name: Get YDB info & Service Account ID
        id: yc-info
        run: |
          YDB_INFO=$(yc ydb database get drevo-db --format json)
          FULL_ENDPOINT=$(echo $YDB_INFO | jq -r '.endpoint')
          echo "ydb_endpoint=$(echo "$FULL_ENDPOINT" | cut -d'?' -f1 | sed 's|/$||')" >> $GITHUB_OUTPUT
          echo "ydb_database=$(echo "$FULL_ENDPOINT" | sed 's/.*database=\(.*\)/\1/')" >> $GITHUB_OUTPUT
          echo "sa_id=$(yc iam service-account get drevo-sa --format json | jq -r '.id')" >> $GITHUB_OUTPUT

      - name: Upload function package to S3
        run: |
          yc storage s3api put-object \
            --bucket=${{ env.MEDIA_BUCKET }} \
            --key=deploy/api.zip \
            --body=backend/api.zip

      - name: Deploy Cloud Function
        run: |
          yc serverless function version create \
            --function-name=${{ env.FUNCTION_NAME }} \
            --runtime=nodejs22 \
            --entrypoint=handler.handler \
            --memory=512m \
            --execution-timeout=60s \
            --package-bucket-name=${{ env.MEDIA_BUCKET }} \
            --package-object-name=deploy/api.zip \
            --service-account-id=${{ steps.yc-info.outputs.sa_id }} \
            --environment="JWT_SECRET=${{ secrets.JWT_SECRET }},YDB_ENDPOINT=${{ steps.yc-info.outputs.ydb_endpoint }},YDB_DATABASE=${{ steps.yc-info.outputs.ydb_database }},MEDIA_MOUNT=/mnt/media" \
            --storage-mounts="mount-point=media,bucket=${{ env.MEDIA_BUCKET }},prefix=,read-only=false"

      # ─── Deploy SPA to Object Storage ────────────────────
      - name: Upload SPA
        run: |
          echo "=== Build output ==="
          find frontend -type f | wc -l

          echo "=== Uploading to ${{ env.SPA_BUCKET }} (parallel) ==="
          cd frontend

          FAIL_LOG=$(mktemp)
          upload_file() {
            local file="$1"
            local key="${file#./}"
            local ct
            case "${key##*.}" in
              html) ct="text/html; charset=utf-8" ;;
              css)  ct="text/css" ;;
              js)   ct="application/javascript" ;;
              json) ct="application/json" ;;
              svg)  ct="image/svg+xml" ;;
              png)  ct="image/png" ;;
              jpg|jpeg) ct="image/jpeg" ;;
              ico)  ct="image/x-icon" ;;
              txt)  ct="text/x-component" ;;
              woff) ct="font/woff" ;;
              woff2) ct="font/woff2" ;;
              map)  ct="application/json" ;;
              *)    ct="application/octet-stream" ;;
            esac
            if yc storage s3api put-object \
              --bucket=${{ env.SPA_BUCKET }} \
              --key="$key" \
              --body="$file" \
              --content-type="$ct" > /dev/null 2>&1; then
              echo "  uploaded: $key ($ct)"
            else
              echo "$key" >> "$FAIL_LOG"
              echo "  FAILED: $key"
            fi
          }
          export -f upload_file
          export FAIL_LOG

          find . -type f -print0 | xargs -0 -P 50 -n 1 bash -c 'upload_file "$1"' _

          if [ -s "$FAIL_LOG" ]; then
            echo "::error::Failed to upload $(wc -l < "$FAIL_LOG") files:"
            cat "$FAIL_LOG"
            rm -f "$FAIL_LOG"
            exit 1
          fi
          rm -f "$FAIL_LOG"
          echo "=== Upload complete ==="

      # ─── Cleanup ─────────────────────────────────────────
      - name: Cleanup
        if: always()
        run: rm -f /tmp/sa-key.json
